"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flowStructureUtil = void 0;
const common_1 = require("../../common");
const activepieces_error_1 = require("../../common/activepieces-error");
const action_1 = require("../actions/action");
const trigger_1 = require("../triggers/trigger");
function isAction(type) {
    return Object.entries(action_1.ActionType).some(([, value]) => value === type);
}
function isTrigger(type) {
    return Object.entries(trigger_1.TriggerType).some(([, value]) => value === type);
}
function getActionOrThrow(name, flowRoot) {
    const step = getStepOrThrow(name, flowRoot);
    if (!isAction(step.type)) {
        throw new activepieces_error_1.ActivepiecesError({
            code: activepieces_error_1.ErrorCode.STEP_NOT_FOUND,
            params: {
                stepName: name,
            },
        });
    }
    return step;
}
function getTriggerOrThrow(name, flowRoot) {
    const step = getStepOrThrow(name, flowRoot);
    if (!isTrigger(step.type)) {
        throw new activepieces_error_1.ActivepiecesError({
            code: activepieces_error_1.ErrorCode.STEP_NOT_FOUND,
            params: {
                stepName: name,
            },
        });
    }
    return step;
}
function getStep(name, flowRoot) {
    return getAllSteps(flowRoot).find((step) => step.name === name);
}
function getStepOrThrow(name, flowRoot) {
    const step = getStep(name, flowRoot);
    if ((0, common_1.isNil)(step)) {
        throw new activepieces_error_1.ActivepiecesError({
            code: activepieces_error_1.ErrorCode.STEP_NOT_FOUND,
            params: {
                stepName: name,
            },
        });
    }
    return step;
}
function transferStep(step, transferFunction) {
    const updatedStep = transferFunction(step);
    switch (updatedStep.type) {
        case action_1.ActionType.LOOP_ON_ITEMS: {
            const { firstLoopAction } = updatedStep;
            if (firstLoopAction) {
                updatedStep.firstLoopAction = transferStep(firstLoopAction, transferFunction);
            }
            break;
        }
        case action_1.ActionType.ROUTER: {
            const { children } = updatedStep;
            if (children) {
                updatedStep.children = children.map((child) => child ? transferStep(child, transferFunction) : null);
            }
            break;
        }
        default:
            break;
    }
    if (updatedStep.nextAction) {
        updatedStep.nextAction = transferStep(updatedStep.nextAction, transferFunction);
    }
    return updatedStep;
}
function transferFlow(flowVersion, transferFunction) {
    const clonedFlow = JSON.parse(JSON.stringify(flowVersion));
    clonedFlow.trigger = transferStep(clonedFlow.trigger, transferFunction);
    return clonedFlow;
}
function getAllSteps(step) {
    const steps = [];
    transferStep(step, (currentStep) => {
        steps.push(currentStep);
        return currentStep;
    });
    return steps;
}
const createBranch = (branchName, conditions) => {
    return {
        conditions: conditions !== null && conditions !== void 0 ? conditions : [[action_1.emptyCondition]],
        branchType: action_1.BranchExecutionType.CONDITION,
        branchName,
    };
};
function findPathToStep(trigger, targetStepName) {
    const steps = exports.flowStructureUtil.getAllSteps(trigger).map((step, dfsIndex) => (Object.assign(Object.assign({}, step), { dfsIndex })));
    return steps
        .filter((step) => {
        const steps = exports.flowStructureUtil.getAllSteps(step);
        return steps.some((s) => s.name === targetStepName);
    })
        .filter((step) => step.name !== targetStepName);
}
function getAllChildSteps(action) {
    return getAllSteps(Object.assign(Object.assign({}, action), { nextAction: undefined }));
}
function isChildOf(parent, childStepName) {
    switch (parent.type) {
        case action_1.ActionType.ROUTER:
        case action_1.ActionType.LOOP_ON_ITEMS: {
            const children = getAllChildSteps(parent);
            return children.findIndex((c) => c.name === childStepName) > -1;
        }
        default:
            break;
    }
    return false;
}
const findUnusedName = (source) => {
    const names = Array.isArray(source) ? source : exports.flowStructureUtil.getAllSteps(source).map((f) => f.name);
    let index = 1;
    let name = 'step_1';
    while (names.includes(name)) {
        index++;
        name = 'step_' + index;
    }
    return name;
};
function getAllNextActionsWithoutChildren(start) {
    const actions = [];
    let currentAction = start.nextAction;
    while (!(0, common_1.isNil)(currentAction)) {
        actions.push(currentAction);
        currentAction = currentAction.nextAction;
    }
    return actions;
}
exports.flowStructureUtil = {
    isTrigger,
    isAction,
    getAllSteps,
    transferStep,
    transferFlow,
    getStepOrThrow,
    getActionOrThrow,
    getTriggerOrThrow,
    getStep,
    createBranch,
    findPathToStep,
    isChildOf,
    findUnusedName,
    getAllNextActionsWithoutChildren,
    getAllChildSteps,
};
//# sourceMappingURL=flow-structure-util.js.map