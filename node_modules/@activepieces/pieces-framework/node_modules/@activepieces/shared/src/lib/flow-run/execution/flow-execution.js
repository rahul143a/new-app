"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isFailedState = exports.isFlowStateTerminal = exports.isFlowUserTerminalState = exports.FlowRunResponse = exports.FlowError = exports.PauseMetadata = exports.WebhookPauseMetadata = exports.StopResponse = exports.RespondResponse = exports.DelayPauseMetadata = exports.PauseType = exports.FlowRunStatus = void 0;
const typebox_1 = require("@sinclair/typebox");
const engine_1 = require("../../engine");
var FlowRunStatus;
(function (FlowRunStatus) {
    FlowRunStatus["FAILED"] = "FAILED";
    FlowRunStatus["QUOTA_EXCEEDED"] = "QUOTA_EXCEEDED";
    FlowRunStatus["INTERNAL_ERROR"] = "INTERNAL_ERROR";
    FlowRunStatus["PAUSED"] = "PAUSED";
    FlowRunStatus["RUNNING"] = "RUNNING";
    FlowRunStatus["STOPPED"] = "STOPPED";
    FlowRunStatus["SUCCEEDED"] = "SUCCEEDED";
    FlowRunStatus["MEMORY_LIMIT_EXCEEDED"] = "MEMORY_LIMIT_EXCEEDED";
    FlowRunStatus["TIMEOUT"] = "TIMEOUT";
})(FlowRunStatus || (exports.FlowRunStatus = FlowRunStatus = {}));
var PauseType;
(function (PauseType) {
    PauseType["DELAY"] = "DELAY";
    PauseType["WEBHOOK"] = "WEBHOOK";
})(PauseType || (exports.PauseType = PauseType = {}));
exports.DelayPauseMetadata = typebox_1.Type.Object({
    type: typebox_1.Type.Literal(PauseType.DELAY),
    resumeDateTime: typebox_1.Type.String(),
    handlerId: typebox_1.Type.Optional(typebox_1.Type.String({})),
    progressUpdateType: typebox_1.Type.Optional(typebox_1.Type.Enum(engine_1.ProgressUpdateType)),
});
exports.RespondResponse = typebox_1.Type.Object({
    status: typebox_1.Type.Optional(typebox_1.Type.Number()),
    body: typebox_1.Type.Optional(typebox_1.Type.Unknown()),
    headers: typebox_1.Type.Optional(typebox_1.Type.Record(typebox_1.Type.String(), typebox_1.Type.String())),
});
exports.StopResponse = typebox_1.Type.Object({
    status: typebox_1.Type.Optional(typebox_1.Type.Number()),
    body: typebox_1.Type.Optional(typebox_1.Type.Unknown()),
    headers: typebox_1.Type.Optional(typebox_1.Type.Record(typebox_1.Type.String(), typebox_1.Type.String())),
});
exports.WebhookPauseMetadata = typebox_1.Type.Object({
    type: typebox_1.Type.Literal(PauseType.WEBHOOK),
    requestId: typebox_1.Type.String(),
    response: exports.RespondResponse,
    handlerId: typebox_1.Type.Optional(typebox_1.Type.String({})),
    progressUpdateType: typebox_1.Type.Optional(typebox_1.Type.Enum(engine_1.ProgressUpdateType)),
});
exports.PauseMetadata = typebox_1.Type.Union([exports.DelayPauseMetadata, exports.WebhookPauseMetadata]);
exports.FlowError = typebox_1.Type.Object({
    stepName: typebox_1.Type.String(),
    message: typebox_1.Type.String(),
});
const BaseExecutionResponse = {
    steps: typebox_1.Type.Optional(typebox_1.Type.Record(typebox_1.Type.String(), typebox_1.Type.Unknown())),
    duration: typebox_1.Type.Number(),
    tasks: typebox_1.Type.Optional(typebox_1.Type.Number()),
    tags: typebox_1.Type.Optional(typebox_1.Type.Array(typebox_1.Type.String())),
    error: typebox_1.Type.Optional(exports.FlowError),
    response: typebox_1.Type.Optional(typebox_1.Type.Union([exports.RespondResponse, exports.PauseMetadata])),
};
exports.FlowRunResponse = typebox_1.Type.Union([
    typebox_1.Type.Object(Object.assign(Object.assign({}, BaseExecutionResponse), { status: typebox_1.Type.Literal(FlowRunStatus.PAUSED), pauseMetadata: typebox_1.Type.Optional(exports.PauseMetadata) })),
    typebox_1.Type.Object(Object.assign(Object.assign({}, BaseExecutionResponse), { status: typebox_1.Type.Union([typebox_1.Type.Literal(FlowRunStatus.FAILED),
            typebox_1.Type.Literal(FlowRunStatus.SUCCEEDED),
            typebox_1.Type.Literal(FlowRunStatus.RUNNING),
            typebox_1.Type.Literal(FlowRunStatus.QUOTA_EXCEEDED),
            typebox_1.Type.Literal(FlowRunStatus.TIMEOUT),
            typebox_1.Type.Literal(FlowRunStatus.INTERNAL_ERROR),
            typebox_1.Type.Literal(FlowRunStatus.MEMORY_LIMIT_EXCEEDED),
            typebox_1.Type.Literal(FlowRunStatus.STOPPED),
        ]) })),
]);
const isFlowUserTerminalState = (status) => {
    return status === FlowRunStatus.SUCCEEDED
        || status === FlowRunStatus.STOPPED
        || status === FlowRunStatus.TIMEOUT
        || status === FlowRunStatus.FAILED
        || status === FlowRunStatus.QUOTA_EXCEEDED
        || status === FlowRunStatus.MEMORY_LIMIT_EXCEEDED;
};
exports.isFlowUserTerminalState = isFlowUserTerminalState;
const isFlowStateTerminal = (status) => {
    return (0, exports.isFlowUserTerminalState)(status) || status === FlowRunStatus.INTERNAL_ERROR;
};
exports.isFlowStateTerminal = isFlowStateTerminal;
const isFailedState = (status) => {
    return status === FlowRunStatus.FAILED
        || status === FlowRunStatus.INTERNAL_ERROR
        || status === FlowRunStatus.QUOTA_EXCEEDED
        || status === FlowRunStatus.TIMEOUT
        || status === FlowRunStatus.MEMORY_LIMIT_EXCEEDED;
};
exports.isFailedState = isFailedState;
//# sourceMappingURL=flow-execution.js.map