"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flowHelper = exports.getImportOperations = void 0;
const tslib_1 = require("tslib");
const flow_operations_1 = require("./flow-operations");
const action_1 = require("./actions/action");
const trigger_1 = require("./triggers/trigger");
const compiler_1 = require("@sinclair/typebox/compiler");
const flow_version_1 = require("./flow-version");
const activepieces_error_1 = require("../common/activepieces-error");
const semver_1 = tslib_1.__importDefault(require("semver"));
const actionSchemaValidator = compiler_1.TypeCompiler.Compile(action_1.SingleActionSchema);
const triggerSchemaValidation = compiler_1.TypeCompiler.Compile(trigger_1.Trigger);
function isValid(flowVersion) {
    let valid = true;
    const steps = exports.flowHelper.getAllSteps(flowVersion.trigger);
    for (let i = 0; i < steps.length; i++) {
        const step = steps[i];
        valid = valid && step.valid;
    }
    return valid;
}
function isAction(type) {
    return Object.entries(action_1.ActionType).some(([, value]) => value === type);
}
function isTrigger(type) {
    return Object.entries(trigger_1.TriggerType).some(([, value]) => value === type);
}
function deleteAction(flowVersion, request) {
    return transferFlow(flowVersion, (parentStep) => {
        if (parentStep.nextAction && parentStep.nextAction.name === request.name) {
            const stepToUpdate = parentStep.nextAction;
            parentStep.nextAction = stepToUpdate.nextAction;
        }
        switch (parentStep.type) {
            case action_1.ActionType.BRANCH: {
                if (parentStep.onFailureAction &&
                    parentStep.onFailureAction.name === request.name) {
                    const stepToUpdate = parentStep.onFailureAction;
                    parentStep.onFailureAction = stepToUpdate.nextAction;
                }
                if (parentStep.onSuccessAction &&
                    parentStep.onSuccessAction.name === request.name) {
                    const stepToUpdate = parentStep.onSuccessAction;
                    parentStep.onSuccessAction = stepToUpdate.nextAction;
                }
                break;
            }
            case action_1.ActionType.LOOP_ON_ITEMS: {
                if (parentStep.firstLoopAction &&
                    parentStep.firstLoopAction.name === request.name) {
                    const stepToUpdate = parentStep.firstLoopAction;
                    parentStep.firstLoopAction = stepToUpdate.nextAction;
                }
                break;
            }
            case action_1.ActionType.CODE:
            case action_1.ActionType.MISSING:
            case action_1.ActionType.PIECE:
                break;
        }
        return parentStep;
    });
}
function getUsedPieces(trigger) {
    return traverseInternal(trigger)
        .filter((step) => step.type === action_1.ActionType.PIECE || step.type === trigger_1.TriggerType.PIECE)
        .map((step) => step.settings.pieceName)
        .filter((value, index, self) => self.indexOf(value) === index);
}
function traverseInternal(step) {
    const steps = [];
    while (step !== undefined && step !== null) {
        steps.push(step);
        if (step.type === action_1.ActionType.BRANCH) {
            steps.push(...traverseInternal(step.onFailureAction));
            steps.push(...traverseInternal(step.onSuccessAction));
        }
        if (step.type === action_1.ActionType.LOOP_ON_ITEMS) {
            steps.push(...traverseInternal(step.firstLoopAction));
        }
        step = step.nextAction;
    }
    return steps;
}
function transferStepAsync(step, transferFunction) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const updatedStep = yield transferFunction(step);
        if (updatedStep.type === action_1.ActionType.BRANCH) {
            const { onSuccessAction, onFailureAction } = updatedStep;
            if (onSuccessAction) {
                updatedStep.onSuccessAction = (yield transferStepAsync(onSuccessAction, transferFunction));
            }
            if (onFailureAction) {
                updatedStep.onFailureAction = (yield transferStepAsync(onFailureAction, transferFunction));
            }
        }
        else if (updatedStep.type === action_1.ActionType.LOOP_ON_ITEMS) {
            const { firstLoopAction } = updatedStep;
            if (firstLoopAction) {
                updatedStep.firstLoopAction = (yield transferStepAsync(firstLoopAction, transferFunction));
            }
        }
        if (updatedStep.nextAction) {
            updatedStep.nextAction = (yield transferStepAsync(updatedStep.nextAction, transferFunction));
        }
        return updatedStep;
    });
}
function transferStep(step, transferFunction) {
    const updatedStep = transferFunction(step);
    if (updatedStep.type === action_1.ActionType.BRANCH) {
        const { onSuccessAction, onFailureAction } = updatedStep;
        if (onSuccessAction) {
            updatedStep.onSuccessAction = transferStep(onSuccessAction, transferFunction);
        }
        if (onFailureAction) {
            updatedStep.onFailureAction = transferStep(onFailureAction, transferFunction);
        }
    }
    else if (updatedStep.type === action_1.ActionType.LOOP_ON_ITEMS) {
        const { firstLoopAction } = updatedStep;
        if (firstLoopAction) {
            updatedStep.firstLoopAction = transferStep(firstLoopAction, transferFunction);
        }
    }
    if (updatedStep.nextAction) {
        updatedStep.nextAction = transferStep(updatedStep.nextAction, transferFunction);
    }
    return updatedStep;
}
function transferFlowAsync(flowVersion, transferFunction) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const clonedFlow = JSON.parse(JSON.stringify(flowVersion));
        clonedFlow.trigger = (yield transferStepAsync(clonedFlow.trigger, transferFunction));
        return clonedFlow;
    });
}
function transferFlow(flowVersion, transferFunction) {
    const clonedFlow = JSON.parse(JSON.stringify(flowVersion));
    clonedFlow.trigger = transferStep(clonedFlow.trigger, transferFunction);
    return clonedFlow;
}
function getAllSteps(trigger) {
    return traverseInternal(trigger);
}
function getAllStepsAtFirstLevel(step) {
    const steps = [];
    while (step !== undefined && step !== null) {
        steps.push(step);
        step = step.nextAction;
    }
    return steps;
}
function getAllChildSteps(action) {
    switch (action.type) {
        case action_1.ActionType.LOOP_ON_ITEMS:
            return traverseInternal(action.firstLoopAction);
        default:
            return [
                ...traverseInternal(action.onSuccessAction),
                ...traverseInternal(action.onFailureAction)
            ];
    }
}
function getStep(flowVersion, stepName) {
    return getAllSteps(flowVersion.trigger).find((step) => step.name === stepName);
}
const getAllSubFlowSteps = ({ subFlowStartStep }) => {
    return traverseInternal(subFlowStartStep);
};
const getStepFromSubFlow = ({ subFlowStartStep, stepName }) => {
    const subFlowSteps = getAllSubFlowSteps({
        subFlowStartStep
    });
    return subFlowSteps.find((step) => step.name === stepName);
};
function updateAction(flowVersion, request) {
    return transferFlow(flowVersion, (parentStep) => {
        if (parentStep.nextAction && parentStep.nextAction.name === request.name) {
            const actions = extractActions(parentStep.nextAction);
            parentStep.nextAction = createAction(request, actions);
        }
        if (parentStep.type === action_1.ActionType.BRANCH) {
            if (parentStep.onFailureAction &&
                parentStep.onFailureAction.name === request.name) {
                const actions = extractActions(parentStep.onFailureAction);
                parentStep.onFailureAction = createAction(request, actions);
            }
            if (parentStep.onSuccessAction &&
                parentStep.onSuccessAction.name === request.name) {
                const actions = extractActions(parentStep.onSuccessAction);
                parentStep.onSuccessAction = createAction(request, actions);
            }
        }
        if (parentStep.type === action_1.ActionType.LOOP_ON_ITEMS) {
            if (parentStep.firstLoopAction &&
                parentStep.firstLoopAction.name === request.name) {
                const actions = extractActions(parentStep.firstLoopAction);
                parentStep.firstLoopAction = createAction(request, actions);
            }
        }
        return parentStep;
    });
}
function extractActions(step) {
    const nextAction = step.nextAction;
    const onSuccessAction = step.type === action_1.ActionType.BRANCH ? step.onSuccessAction : undefined;
    const onFailureAction = step.type === action_1.ActionType.BRANCH ? step.onFailureAction : undefined;
    const firstLoopAction = step.type === action_1.ActionType.LOOP_ON_ITEMS ? step.firstLoopAction : undefined;
    return { nextAction, onSuccessAction, onFailureAction, firstLoopAction };
}
function moveAction(flowVersion, request) {
    const steps = getAllSteps(flowVersion.trigger);
    const sourceStep = steps.find((step) => step.name === request.name);
    if (!sourceStep || !isAction(sourceStep === null || sourceStep === void 0 ? void 0 : sourceStep.type)) {
        throw new activepieces_error_1.ActivepiecesError({
            code: activepieces_error_1.ErrorCode.FLOW_OPERATION_INVALID,
            params: {}
        }, `Source step ${request.name} not found`);
    }
    const destinationStep = steps.find((step) => step.name === request.newParentStep);
    if (!destinationStep) {
        throw new activepieces_error_1.ActivepiecesError({
            code: activepieces_error_1.ErrorCode.FLOW_OPERATION_INVALID,
            params: {}
        }, `Destination step ${request.newParentStep} not found`);
    }
    const childOperation = [];
    const clonedSourceStep = JSON.parse(JSON.stringify(sourceStep));
    if (clonedSourceStep.type === action_1.ActionType.LOOP_ON_ITEMS ||
        clonedSourceStep.type === action_1.ActionType.BRANCH) {
        // Don't Clone the next action for first step only
        clonedSourceStep.nextAction = undefined;
        childOperation.push(...getImportOperations(clonedSourceStep));
    }
    flowVersion = deleteAction(flowVersion, { name: request.name });
    flowVersion = addAction(flowVersion, {
        action: sourceStep,
        parentStep: request.newParentStep,
        stepLocationRelativeToParent: request.stepLocationRelativeToNewParent
    });
    childOperation.forEach((operation) => {
        flowVersion = exports.flowHelper.apply(flowVersion, operation);
    });
    return flowVersion;
}
function addAction(flowVersion, request) {
    return transferFlow(flowVersion, (parentStep) => {
        if (parentStep.name !== request.parentStep) {
            return parentStep;
        }
        if (parentStep.type === action_1.ActionType.LOOP_ON_ITEMS &&
            request.stepLocationRelativeToParent) {
            if (request.stepLocationRelativeToParent ===
                flow_operations_1.StepLocationRelativeToParent.INSIDE_LOOP) {
                parentStep.firstLoopAction = createAction(request.action, {
                    nextAction: parentStep.firstLoopAction
                });
            }
            else if (request.stepLocationRelativeToParent ===
                flow_operations_1.StepLocationRelativeToParent.AFTER) {
                parentStep.nextAction = createAction(request.action, {
                    nextAction: parentStep.nextAction
                });
            }
            else {
                throw new activepieces_error_1.ActivepiecesError({
                    code: activepieces_error_1.ErrorCode.FLOW_OPERATION_INVALID,
                    params: {}
                }, `Loop step parent ${request.stepLocationRelativeToParent} not found`);
            }
        }
        else if (parentStep.type === action_1.ActionType.BRANCH &&
            request.stepLocationRelativeToParent) {
            if (request.stepLocationRelativeToParent ===
                flow_operations_1.StepLocationRelativeToParent.INSIDE_TRUE_BRANCH) {
                parentStep.onSuccessAction = createAction(request.action, {
                    nextAction: parentStep.onSuccessAction
                });
            }
            else if (request.stepLocationRelativeToParent ===
                flow_operations_1.StepLocationRelativeToParent.INSIDE_FALSE_BRANCH) {
                parentStep.onFailureAction = createAction(request.action, {
                    nextAction: parentStep.onFailureAction
                });
            }
            else if (request.stepLocationRelativeToParent ===
                flow_operations_1.StepLocationRelativeToParent.AFTER) {
                parentStep.nextAction = createAction(request.action, {
                    nextAction: parentStep.nextAction
                });
            }
            else {
                throw new activepieces_error_1.ActivepiecesError({
                    code: activepieces_error_1.ErrorCode.FLOW_OPERATION_INVALID,
                    params: {}
                }, `Branch step parernt ${request.stepLocationRelativeToParent} not found`);
            }
        }
        else {
            parentStep.nextAction = createAction(request.action, {
                nextAction: parentStep.nextAction
            });
        }
        return parentStep;
    });
}
function createAction(request, { nextAction, onFailureAction, onSuccessAction, firstLoopAction }) {
    var _a;
    const baseProperties = {
        displayName: request.displayName,
        name: request.name,
        valid: false,
        nextAction: nextAction
    };
    let action;
    switch (request.type) {
        case action_1.ActionType.BRANCH:
            action = Object.assign(Object.assign({}, baseProperties), { onFailureAction: onFailureAction, onSuccessAction: onSuccessAction, type: action_1.ActionType.BRANCH, settings: request.settings });
            break;
        case action_1.ActionType.LOOP_ON_ITEMS:
            action = Object.assign(Object.assign({}, baseProperties), { firstLoopAction: firstLoopAction, type: action_1.ActionType.LOOP_ON_ITEMS, settings: request.settings });
            break;
        case action_1.ActionType.PIECE:
            action = Object.assign(Object.assign({}, baseProperties), { type: action_1.ActionType.PIECE, settings: request.settings });
            break;
        case action_1.ActionType.CODE:
            action = Object.assign(Object.assign({}, baseProperties), { type: action_1.ActionType.CODE, settings: request.settings });
            break;
        case action_1.ActionType.MISSING:
            action = Object.assign(Object.assign({}, baseProperties), { type: action_1.ActionType.MISSING, settings: request.settings });
    }
    action.valid = ((_a = request.valid) !== null && _a !== void 0 ? _a : true) && actionSchemaValidator.Check(action);
    return action;
}
function isChildOf(parent, child) {
    switch (parent.type) {
        case action_1.ActionType.LOOP_ON_ITEMS: {
            const children = getAllChildSteps(parent);
            return children.findIndex((c) => c.name === child.name) > -1;
        }
        default: {
            const children = [
                ...getAllChildSteps(parent),
                ...getAllChildSteps(parent)
            ];
            return children.findIndex((c) => c.name === child.name) > -1;
        }
    }
}
function createTrigger(name, request, nextAction) {
    var _a;
    const baseProperties = {
        displayName: request.displayName,
        name: name,
        valid: false,
        nextAction: nextAction
    };
    let trigger;
    switch (request.type) {
        case trigger_1.TriggerType.EMPTY:
            trigger = Object.assign(Object.assign({}, baseProperties), { type: trigger_1.TriggerType.EMPTY, settings: request.settings });
            break;
        case trigger_1.TriggerType.PIECE:
            trigger = Object.assign(Object.assign({}, baseProperties), { type: trigger_1.TriggerType.PIECE, settings: request.settings });
            break;
        case trigger_1.TriggerType.WEBHOOK:
            trigger = Object.assign(Object.assign({}, baseProperties), { type: trigger_1.TriggerType.WEBHOOK, settings: request.settings });
            break;
    }
    trigger.valid =
        ((_a = request.valid) !== null && _a !== void 0 ? _a : true) && triggerSchemaValidation.Check(trigger);
    return trigger;
}
function getImportOperations(step) {
    const steps = [];
    while (step) {
        if (step.nextAction) {
            steps.push({
                type: flow_operations_1.FlowOperationType.ADD_ACTION,
                request: {
                    parentStep: step.name,
                    action: keepBaseAction(step.nextAction)
                }
            });
        }
        if (step.type === action_1.ActionType.BRANCH) {
            if (step.onFailureAction) {
                steps.push({
                    type: flow_operations_1.FlowOperationType.ADD_ACTION,
                    request: {
                        parentStep: step.name,
                        stepLocationRelativeToParent: flow_operations_1.StepLocationRelativeToParent.INSIDE_FALSE_BRANCH,
                        action: keepBaseAction(step.onFailureAction)
                    }
                });
                steps.push(...getImportOperations(step.onFailureAction));
            }
            if (step.onSuccessAction) {
                steps.push({
                    type: flow_operations_1.FlowOperationType.ADD_ACTION,
                    request: {
                        parentStep: step.name,
                        stepLocationRelativeToParent: flow_operations_1.StepLocationRelativeToParent.INSIDE_TRUE_BRANCH,
                        action: keepBaseAction(step.onSuccessAction)
                    }
                });
                steps.push(...getImportOperations(step.onSuccessAction));
            }
        }
        if (step.type === action_1.ActionType.LOOP_ON_ITEMS && step.firstLoopAction) {
            steps.push({
                type: flow_operations_1.FlowOperationType.ADD_ACTION,
                request: {
                    parentStep: step.name,
                    stepLocationRelativeToParent: flow_operations_1.StepLocationRelativeToParent.INSIDE_LOOP,
                    action: keepBaseAction(step.firstLoopAction)
                }
            });
            steps.push(...getImportOperations(step.firstLoopAction));
        }
        step = step.nextAction;
    }
    return steps;
}
exports.getImportOperations = getImportOperations;
// It's better to use switch case, to enforce that all actions are covered
// TODO this can be simplified
function keepBaseAction(action) {
    const commonProps = {
        name: action.name,
        displayName: action.displayName,
        valid: action.valid
    };
    switch (action.type) {
        case action_1.ActionType.BRANCH:
            // PICK type and settings from action
            return Object.assign({ type: action_1.ActionType.BRANCH, settings: action.settings }, commonProps);
        case action_1.ActionType.LOOP_ON_ITEMS:
            return Object.assign({ type: action_1.ActionType.LOOP_ON_ITEMS, settings: action.settings }, commonProps);
        case action_1.ActionType.CODE:
            return Object.assign({ type: action.type, settings: Object.assign(Object.assign({}, action.settings), { artifactPackagedId: undefined, artifactSourceId: undefined }) }, commonProps);
        case action_1.ActionType.PIECE:
            return Object.assign({ type: action.type, settings: action.settings }, commonProps);
        case action_1.ActionType.MISSING:
            return Object.assign({ type: action.type, settings: action.settings }, commonProps);
    }
}
function upgradePiece(step, stepName) {
    if (step.name !== stepName) {
        return step;
    }
    const clonedStep = JSON.parse(JSON.stringify(step));
    switch (step.type) {
        case action_1.ActionType.PIECE:
        case trigger_1.TriggerType.PIECE: {
            const { pieceVersion, pieceName } = step.settings;
            if (isLegacyApp({ pieceName, pieceVersion })) {
                return step;
            }
            if (pieceVersion.startsWith('^') || pieceVersion.startsWith('~')) {
                return step;
            }
            if (semver_1.default.valid(pieceVersion) && semver_1.default.lt(pieceVersion, '1.0.0')) {
                clonedStep.settings.pieceVersion = `~${pieceVersion}`;
            }
            else {
                clonedStep.settings.pieceVersion = `^${pieceVersion}`;
            }
            break;
        }
    }
    return clonedStep;
}
// TODO Remove this in 2024, these pieces didn't follow the standarad versioning where the minor version has to be increased when there is breaking change.
function isLegacyApp({ pieceName, pieceVersion }) {
    let newVersion = pieceVersion;
    if (newVersion.startsWith("^") || newVersion.startsWith("~")) {
        newVersion = newVersion.substring(1);
    }
    if (pieceName === '@activepieces/piece-google-sheets' &&
        semver_1.default.lt(newVersion, '0.3.0')) {
        return true;
    }
    if (pieceName === '@activepieces/piece-gmail' &&
        semver_1.default.lt(newVersion, '0.3.0')) {
        return true;
    }
    return false;
}
exports.flowHelper = {
    isValid: isValid,
    apply(flowVersion, operation) {
        let clonedVersion = JSON.parse(JSON.stringify(flowVersion));
        switch (operation.type) {
            case flow_operations_1.FlowOperationType.MOVE_ACTION:
                clonedVersion = moveAction(clonedVersion, operation.request);
                break;
            case flow_operations_1.FlowOperationType.LOCK_FLOW:
                clonedVersion.state = flow_version_1.FlowVersionState.LOCKED;
                break;
            case flow_operations_1.FlowOperationType.CHANGE_NAME:
                clonedVersion.displayName = operation.request.displayName;
                break;
            case flow_operations_1.FlowOperationType.DELETE_ACTION:
                clonedVersion = deleteAction(clonedVersion, operation.request);
                break;
            case flow_operations_1.FlowOperationType.ADD_ACTION: {
                clonedVersion = transferFlow(addAction(clonedVersion, operation.request), (step) => upgradePiece(step, operation.request.action.name));
                break;
            }
            case flow_operations_1.FlowOperationType.UPDATE_ACTION:
                clonedVersion = transferFlow(updateAction(clonedVersion, operation.request), (step) => upgradePiece(step, operation.request.name));
                break;
            case flow_operations_1.FlowOperationType.UPDATE_TRIGGER:
                clonedVersion.trigger = createTrigger(clonedVersion.trigger.name, operation.request, clonedVersion.trigger.nextAction);
                clonedVersion = transferFlow(clonedVersion, (step) => upgradePiece(step, operation.request.name));
                break;
        }
        clonedVersion.valid = isValid(clonedVersion);
        return clonedVersion;
    },
    getStep,
    isAction,
    isTrigger,
    getAllSteps,
    getUsedPieces,
    getImportOperations,
    getAllSubFlowSteps,
    getStepFromSubFlow,
    isChildOf,
    transferFlowAsync,
    getAllChildSteps,
    getAllStepsAtFirstLevel
};
//# sourceMappingURL=flow-helper.js.map